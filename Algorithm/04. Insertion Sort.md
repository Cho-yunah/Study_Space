# 04. 삽입정렬

## 1. 삽입 정렬이란

- 이전에 정리했던 선택 정렬의 경우, 앞쪽 작은 수인 하위 배열부터 정렬하기 시작하기 때문에 뒤쪽의 하위배열은 건드리지 않는다. 이미 정렬된 하위 배열에 새로이 추가되는 요소가 이 정렬된 하위 배열에 있는 요소보다 더 작지는 않다.
- 삽입 정렬의 경우는 새로 추가할 수를 한번에 올바른 위치에 끼워넣는 방법이다. 기존의 배열에서 하나의 수를 택하여 배열을 따라 순환하며 택한 수와 배열의 모든 수를 일일이 비교하여 알맞는 자리를 찾아넣는 방법이다.

## 2. 삽입 정렬의 원리

- 인덱스 0번부터 5번까지 이미 정렬되어 있는 배열을 생각해본다. 인덱스 6번에 있는 요소를 이 정렬된 배열에 끼워넣어서 인덱스 0번부터 6번까지 정렬되도록 한다면 어떻게 해야할까.
    1. 인덱스 6번 위치에 있는 한 요소를 그 왼쪽 하위 배열 안에 삽입하기 위해 반복적으로 바로 왼쪽의 요소들과 비교하며 움직인다. 
    2. 6번 위치의 요소를 key라고 부른다면, 이 key가 그 왼쪽에 있는 요소보다 크기가 작으면 비교한 요소를 오른쪽으로 한 칸 움직인다.
    3. 비교 요소가 오른쪽으로 움직이면 비게된 자리에 key를 넣는다.
    4. 같은 방법으로 key를 반복적으로 왼쪽의 값과 비교하여 적합한 위치에 넣음으로써 정렬된 배열을 만든다.
- 삽입 정렬은 어떤 요소를 왼쪽의 정렬된 하위 배열 안으로 반복적으로 삽입하는 방식이다. 처음에는 인덱스 0만이 존재하는 배열이 정렬되었다고 생각한다. 그리고 이 배열에 여러 수를 적합한 위치에 넣어서 정렬시킨다는 것으로 생각하면 된다.

## 3. 삽입 정렬의 의사코드

1. 배열 내에 주어진 값을 정확히 삽입할 수 있도록 `insert` 함수를 구현 한다.
    - insert 함수는 array, rightIndex, value 이렇게 총 세가지의 매개변수를 가진다.
    - insert 함수는 오른쪽의 value 보다 큰 항목들을 움직여 value에 자리를 내준다. rightindex에서 시작하여 value보다 작거나 동일한 항목을 찾을 때 또는 배열의 첫부분에 이를때 멈추어야 한다.
2. insert 를 호출하여 인덱스 0의 정렬된 하위 배열에 인덱스 1부터 시작하는 요소를 삽입한다.
3. insert 를 호출하여 인덱스 0에서 2까지 정렬된 하위 배열에 인덱스 2부터 시작하는 요소를 삽입한다.
4. 위와 같이 insert 를 호출하여 요소를 삽입하는 과정을 반복한다.
5. 마지막으로 insert 를 호출하여 인덱스 0에서 n-2까지 정렬된 하위 배열에 인덱스 n-1부터 시작하는 요소를 삽입한다.

## 4. 삽입정렬 구현

- 위와 같은 의사코드를 실제 코드로 구현해보자

    ```jsx
    var insert = function(array, rightIndex, value) {
        for(var j = rightIndex;
            j >= 0 && array[j] > value;
            j--) {
            array[j + 1] = array[j];
        }   
        array[j+1] = value; 
    };

    var insertionSort = function(array) {
        for (var i =0; i<array.length-1; i++) {
            insert (array, i,array[i+1]);
        }
    };

    var array = [22, 11, 99, 88, 9, 7, 42]; // [7, 9, 11, 22, 42, 88, 99]);
    insertionSort(array);
    ```

## 5. 삽입 정렬 분석하기

- 삽입 정렬은 배열의 인덱스를 통해 반복을 한다. 수행하는데 걸리는 시간이 정렬된 하위 배열의 크기에 따라 달라지는 것처럼 각 insert를 수행하는 데 걸리는 시간도 동일하다.
- insert를 호출할 때마다 삽입하려는 수가 하위 배열 왼쪽의 모든 요소보다 작다고 가정한다면, 배열의 모든 요소가 오른쪽으로 한칸씩 이동을 해야하므로 등차급수의 개념이 적용된다.

    ```jsx
    // c는 요소를 삽입하기 위해 필요한 코드 수
    c⋅1+c⋅2+c⋅3+ ⋯ c⋅(n−1)=c⋅(1+2+3+⋯+(n−1))

    => c⋅(n-1+1)((n-1)/2) = cn^2/2 - cn/2
    ```

- big O 표기법에서는 낮은 차수항들을 버리게 되므로 소요되는 시간은 `Θ($*n^2*$)` 이다.
- 정렬된 배열에 모든 배열 요소보다 큰 수를 삽입하려고 할 때는 `Θ(*n2*)` 의 시간이 걸린다.
- 즉, 삽입 정렬의 실행시간을 정리하면,
    - 최악의 경우 :  Θ($n^2)$
    - 최상의 경우 :  Θ(n)
    - 임의의 배열에 대한 평균적 경우 : Θ($n^2$)
    - 거의 정렬된 배열의 경우 : Θ(n)
- 삽입 정렬의 모든 경우에 대해 포괄적으로 표현해야 한다면, 삽입 정렬은 *O*($*n^2*$)동안 실행된다고 해야 한다.
