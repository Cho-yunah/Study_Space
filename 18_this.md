# 18_this



## 1. this 키워드

- 객체는 상태를 나타내는 프로퍼티와 동작(behavior)을 나타내는 메서드를 하나의 논리적인 단위로 묶은 복합적인 자료구조다.

- 동작을 나타내는 메서드는 자신이 속한 객체의 상태, 즉 프로퍼티를 참조하고 변경할 수 있어야 한다. 이때 메서드가 자신이 속한 객체의 프로퍼티를 참조하려면 먼저 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.

- this 라는 개념은 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

- (this를 사용하지 않을 경우를 생각해보자.

  1. 객체 리터럴로 생성한 객체의 경우 메서드 내부에서 메서드 자신이 속한 객체를 가리키는 식별자를 재귀적으로 참조할 수 있다. 하지만 자기자신이 속한 객체를 재귀적으로 참조하는 방식은 바람직하지 않다.

     ```jsx
     const circle = {
       // 프로퍼티: 객체 고유의 상태 데이터
       radius: 5,
       // 메서드: 상태 데이터를 참조하고 조작하는 동작
       getDiameter() {
         // 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드를 참조하려면
         // 자신이 속한 객체인 circle을 참조할 수 있어야 한다.
         **return 2 * circle.radius;**
       }
     };
     
     console.log(circle.getDiameter()); // 10
     ```

  2. 생성자 함수로 객체를 생성할 경우, 생성자 함수 내부에서 프로퍼티 또는 메서드를 추가하기 위해 자신이 생성할 인스턴스를 참조할 수 있어야 한다. 하지만 생성자 함수에 의한 방식은 new 연산자와 함께 생성자 함수를 호출하는 단계가 필요하다. 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 미래에 생성될 인스턴스를 가리키는 식별자를 알수 없다.

     ```jsx
     function Circle(radius) {
       // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
       **????.radius = radius;**
     }
     
     Circle.prototype.getDiameter = function () {
       // 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.
       **return 2 * ????.radius;**
     };
     
     // 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.
     const circle = new Circle(5);
     ```

  - 결국엔 this 라는 개념을 사용하지 않으면 메서드를 사용함에 있어서 어려움이 있다. 즉 this는 키워드로 분류되지만 식별자 역할을 한다.

- 따라서 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요하다. 이를 위해 자바스크립트는 this 라는 특수한 식별자를 제공한다.

- this 는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.

## 2. 함수 호출 방식과 this 바인딩

- this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드어디서든 참조할 수 있다. this가 가리키는 값, 즉 this 바인딩은 함수 호출방식에 의해 동적으로 결정된다.

- this 바인딩 ⇒  호출방식에 따라 바인딩이 달라진다. this를 사용하는 이유는 어떻게 호출이 될지 모르기 때문인데, 전역객체 this는 이미 알고 있으므로 의미가 없다.

  1. 일반함수로 호출

  = 일반적인 방식으로 호출→  전역객체 window에 바인딩 (사실 의미가 없다. )

  1. 생성자 함수로 호출

  = 해당함수를 new 연산자와 함께 호출 → 생성자 함수가 만들어낼 인스턴스에 바인딩

  1. 메서드로 호출

  = 해당 함수를 프로퍼티 값으로 할당하여 호출 → 메서드를 호출한 객체에 바인딩

  1. Function.prototype.apply/call/bind 메서드에 의한 간접 호출

  = 해당 함수 내부의 this는 인수에 의해 결정됨

### 2.1 일반 함수 호출

- 기본적으로 this에 전역 객체(global object)가 바인딩된다.
- 전역함수는 물론 중첩함수를 일반 함수로 호출하면 함수 내부의 this에 전역 객체가 바인딩된다. 그렇지만 this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반함수에서는 의미가 없다.